
# 并查集总结

@(柯帅)[算法总结|数据结构|树型结构|并查集|2015-05-18]

-------------------

[TOC]

-------------------

### 并查集简介
> **并查集**是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题 -- [维基百科](http://zh.wikipedia.org/zh-cn/%E5%B9%B6%E6%9F%A5%E9%9B%86)

**并查集**主要就是一个parent数组，以根节点代表集合，除了根节点以外，parent记录每个元素的父亲节点，根节点记录的为它自己本身。

#### 基本操作
- 查找操作（find）：确定元素所在集合。
- 合并操作（union）：合并两个集合。

#### 模板
``` C++
#include <cstdio>
using namespace std;
int parent[maxn];

void UF_init(int n) {
	for (int i = 0; i <= n; i++)
		parent[i] = i;
}

int UF_find(int x) {
	return x == parent[x] ? x : parent[x] = UF_find(parent[x]);
}

void UF_union(int u, int v) {
	int pu = UF_find(u);
	int pv = UF_find(v);
	if (pu != pv)
		parent[fu] = fv;
}
```

-------------------

### 并查集题型

#### 集合判断
在一系列合并操作后，判断两个元素是否属于同一个集合。

#### 集合个数
在一系列合并操作后，询问某个集合的元素个数。

#### 最小联通分量
在一系列合并操作后，询问当前含有多少个集合。假设开始时集合个数为N，每成功执行一次合并操作，N就相应减一。

#### 带权并查集
集合之间关系不只一种时，相应的合并查询操作也发生改变。

``` C++
#include <cstdio>
using namespace std;
int parent[maxn], relat[maxn], R = 3;

void UF_init(int n) {
	for (int i = 0; i <= n; i++) {
		parent[i] = i;
		relat[i] = 0;
	}
}

int UF_find(int x) {
	if (parent[x] == x)
		return x;

	int px = UF_find(x);
	// According Problem;
	relat[x] = (relat[x] + relat[px]) % R;
	return parent[x] = px;
}

bool UF_union(int u, int v, int rel) {
	int pu = UF_find(u);
	int pv = UF_find(v);

	if (pu != pv) {
		// According Problem;
		relat[pu] = ((relat[v] + rel - relat[u]) % R + R) % R;
		parent[pu] = pv;
	} else
		return ((parent[u] - parent[v]) % R + R) % R == rel;
	return true;
}
``` 

-------------------

### 并查集经典题

#### uva 1493 - Draw a Mess
- [题目链接](http://blog.csdn.net/keshuai19940722/article/details/38873853)

优化可行域查询。parent[i]表示继i之后下一个可行位置。通过并查集压缩路径的思想去优化查找效率。

#### poj 1733 - Parity game
- [题目链接](http://blog.csdn.net/keshuai19940722/article/details/23927971)

将0~i的和作为节点i，这样将问题转化成带权并查集。


-------------------

### 并查集习题补充

#### 集合判断
- [uva 10004 Bicoloring](http://blog.csdn.net/keshuai19940722/article/details/9671817)
- [uva 208 Firetruck](http://blog.csdn.net/keshuai19940722/article/details/9746469)
- [uva 10158 - War](http://blog.csdn.net/keshuai19940722/article/details/12760249)
- [poj 1308 Is It A Tree?](http://blog.csdn.net/keshuai19940722/article/details/23925037)
- [poj 2236 Wireless Network](http://blog.csdn.net/keshuai19940722/article/details/23926357)
- [Codeforces 455C Civilization](http://blog.csdn.net/keshuai19940722/article/details/38455333)
- [uva 1160 - X-Plosives](http://blog.csdn.net/keshuai19940722/article/details/38777975)
- [zoj 3811 Untrusted Patrol](http://blog.csdn.net/keshuai19940722/article/details/39136453)

#### 集合个数
- [poj 1611 The Suspects](http://blog.csdn.net/keshuai19940722/article/details/23925377)
- [uva 10608 - Friends](http://blog.csdn.net/keshuai19940722/article/details/12760017)
- [uva 11987 Almost Union-Find](http://blog.csdn.net/keshuai19940722/article/details/9825251)

#### 最小联通分量
- [Codeforces 445B DZY Loves Chemistry](http://blog.csdn.net/keshuai19940722/article/details/37544619)
- [hdu 4496 D-City](http://blog.csdn.net/keshuai19940722/article/details/24499129)
- [poj 2524 Ubiquitous Religions](http://blog.csdn.net/keshuai19940722/article/details/23927389)

#### 带权并查集
- [poj 1182 食物链](http://blog.csdn.net/keshuai19940722/article/details/23924881)
- [poj 2492 A Bug's Life](http://blog.csdn.net/keshuai19940722/article/details/23926975)
- [poj 2912 Rochambeau](http://blog.csdn.net/keshuai19940722/article/details/23929057)
- [poj 1703 Find them, Catch them](http://blog.csdn.net/keshuai19940722/article/details/23925567)
- [poj 1988 Cube Stacking](http://blog.csdn.net/keshuai19940722/article/details/23926001)
- [hdu 3038 How Many Answers Are Wrong](http://blog.csdn.net/keshuai19940722/article/details/38447233)
- [uva 1329 - Corporative Network](http://blog.csdn.net/keshuai19940722/article/details/38777999)
- [uva 12232 - Exclusive-OR](http://blog.csdn.net/keshuai19940722/article/details/38784797)

#### 其它习题
- [Codeforces 437D The Child and Zoo](http://blog.csdn.net/keshuai19940722/article/details/30774691)（结合数论）
- [Codeforces 400D Dima and Bacteria](http://blog.csdn.net/keshuai19940722/article/details/20702393)（结合Floyd）
- [uva 11106 - Rectilinear Polygon](http://blog.csdn.net/keshuai19940722/article/details/18106337)（优先队列+链表）
- [hud 1811 Rank of Tetris](http://blog.csdn.net/keshuai19940722/article/details/9723855)（拓扑排序）

-------------------

### 并查集拓展-按秩合并

#### 简介
**按秩合并**为并查集的一种优化，在合并两个集合时，将集合元素个数少的合并到集合个数多的。root为1时，该节点为根节点，此时parent记录的为集合元素的个数了；root为0时，该节点为非根节点，parent记录的为它的父亲节点。

#### 代码
``` C++
#include <cstdio>
using namespace std;
struct UFSet {
	int parent, root;
}f[maxn];

void UF_init(int n) {
	for (int i = 0; i <= n; i++) {
		f[i].parent = 1;
		f[i].root = 1;
	}
}

int UF_find(int x) {
	int p, q, tmp;
	p = q = x;
	while (!f[p].root)
		p = f[p].parent;

	while (q != p) {
		tmp = f[q].parent;
		f[q].parent = p;
		q = tmp;
	}
	return p;
}

void UF_union(int u, int v) {
	int fu = UF_find(u);
	int fv = UF_find(v);

	if  (f[fu].parent < f[fv].parent)
		swap(fu, fv);
	f[fu].parent += f[fv].parent;
	f[fv].parent = fu;
	f[fv].root = 0;
}
```
