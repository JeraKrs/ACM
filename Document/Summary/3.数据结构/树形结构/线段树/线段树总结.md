## 线段树总结

@[|ACM/ICPC|算法&数据结构|总结]

##### *引言*
> **线段树**是一种常见的数据结构，主要处理区间上的动态修改查询问题。作为一个学习者，写总结可以加深对知识的掌握，并且方便日后查阅。所以在做完一套线段树专题后准备写一篇关于此的总结。—— [keshuai](http://blog.csdn.net/keshuai19940722?viewmode=contents)

-------------------

#### 简介

>   **线段树**（Segment Tree）是一种二叉搜索树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。
    对于线段树中的每一个非叶子节点$[a,b]$，它的左子树表示的区间为$[a,(a+b)/2]$，右子树表示的区间为$[(a+b)/2+1,b]$。因此线段树是平衡二叉树。叶节点数目为N，即整个线段区间的长度。 —— [维基百科](http://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91)
    
**线段树**的本质是一棵二叉树，通常是用数组实现的，单次查询修改的复杂度均为$log(n)$。线段树中的每个节点记录维护节点所表示的区间信息，并且可以通过左右孩子节点的信息来维护。

###### 基本操作
- 向上更新（pushup）：将孩子节点的信息更新到父亲节点。
- 向下更新（pushdown）：将父亲节点的懒惰标记更新到孩子节点。
- 建树（build）：线段树的初始化。
- 更新操作（modify）：修改区间信息。
- 查询操作（query）：查询区间信息。
- 修改节点（maintain）：修改节点的信息。
（线段树的数组大小一般开maxn的4倍，理论上3倍就已经足够了）

###### 图解
![Alt text](./1-1.png)

###### 代码
``` C++ 框架
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int maxn = 1e5 + 5;
#define lson(x) ((x)<<1)
#define rson(x) (((x)<<1)|1)

int lc[maxn << 2], rc[maxn << 2], nd[maxn << 2], ad[maxn << 2];

inline void maintain (int u, int w) {
	// According Problem;
	nd[u] += ad[u] * (rc[u] - lc[u] + 1);
}

void pushup (int u) {
	// According Problem;
	nd[u] = nd[lson(u)] + nd[rson(u)];
}

void pushdown (int u) {
	// According Problem;
	if (ad[u]) {
		maintain(lson(u), ad[u]);
		maintain(rson(u), ad[u]);
		ad[u] = 0;
	}
}

void segtree_build (int u, int l, int r) {
	lc[u] = l;
	rc[u] = r;
	nd[u] = ad[u] = 0;

	if (l == r) {
		// According Problem;
		return;
	}

	int mid = (l + r) / 2;
	segtree_build(lson(u), l, mid);
	segtree_build(rson(u), mid + 1, r);
	pushup(u);
}

void segtree_modify (int u, int l, int r, int w) {
	if (l <= lc[u] && rc[u] <= r) {
		// According Problem;
		maintain(u, w);
		return ;
	}

	pushdown(u);
	int mid = (lc[u] + rc[u]) >> 1;
	if (l <= mid)
		segtree_modify(lson(u), l, r, w);
	if (r > mid)
		segtree_modify(rson(u), l, r, w);
	pushup(u);
}

int segtree_query (int u, int l, int r) {
	if (l <= lc[u] && rc[u] <= r)
		return nd[u];

	pushdown(u);
	int mid = (lc[u] + rc[u]) >> 1, ret = 0;
	if (l <= mid)
		ret += segtree_query(lson(u), l, r);
	if (r > mid)
		ret += segtree_query(rson(u), l, r);
	pushup(u);
	return ret;
}
```

-------------------

#### 题型

##### 一、单点更新

**单点更新**是线段树最基础的操作，因为每次修改都是在叶子节点上操作，所以不需要延迟操作，也就没有pushdown。

###### 代码
``` C++ 单点更新
void modify(int u, int x, int w) {
	if (x == lc[u] && rc[u] == x) {
		s[u] += w;
		return;
	}

	int mid = (lc[u] + rc[u]) / 2;
	if (x <= mid)
		modify(lson(u), x, w);
	else
		modify(rson(u), x, w);
	pushup(u);
}
```

###### 习题
- [hdu 1166 敌兵布阵](http://blog.csdn.net/keshuai19940722/article/details/18828939)
- [hdu 1754 I Hate It](http://blog.csdn.net/keshuai19940722/article/details/18845389)
- [uva 12299 - RMQ with Shifts](http://blog.csdn.net/keshuai19940722/article/details/38820013)
- [poj 2886 Who Gets the Most Candies?](http://blog.csdn.net/keshuai19940722/article/details/39375147)


##### 二、区间更新

**区间更新**用于处理操作对象为整段区间的问题，如果使用单点更新的方式，单次修改的复杂度即为$nlong(n)$，肯定是不能接受的。而区间更新通过懒惰标记（延迟操作）将单次修改的复杂度优化到$log(n)$，这也是线段树的强大之处。
**懒惰标记**即每次区间操作时，不用将操作更新到叶子节点，而是更新到中间节点，如果这个中间节点所表示的区间在操作的区间范围上，那么即将操作在该节点上进行，并且操作将暂时停留在该节点处。之所以称暂时，是因为如果下一次操作将操作到该节点的子节点时，要将懒惰标记向下更新，即pushdown操作（操作间的先后，重叠将导致结果的不同）。

###### 例题
以[poj 3468](http://poj.org/problem?id=3468)为例，给定一个长度为N的数组，有Q次操作，操作分为两种：C a b c：将区间[a,b]的值均变成c；Q a b：计算区间[a,b]的元素和。
我们将样例的操作变为
`C 1 5 2` `C 3 6 1` `C 1 8 10`

###### 图解
![Alt text](./1-2.png)

###### 代码
``` C++ 区间更新
void modify(int u, int l, int r, int w) {
	if (l <= lc[u] && rc[u] <= r) {
		maintain(u);
		return;
	}

	pushdown(u);
	int mid = (lc[u] + rc[u]) / 2;
	if (l <= mid)
		modify(lson(u), l, r, w);
	if (r > mid)
		modify(rson(u), l, r, w);
	pushup(u);
}
```

###### 习题
- [poj 3468 A Simple Problem with Integers](http://blog.csdn.net/keshuai19940722/article/details/39375237)
- [poj 3225 Help with Intervals](http://blog.csdn.net/keshuai19940722/article/details/39586283)
- [hdu 4719 Oh My Holy FFF](http://blog.csdn.net/keshuai19940722/article/details/25830085)
- [hdu 4983 Wow! Such Sequence!](http://blog.csdn.net/keshuai19940722/article/details/38276425)
- [hdu 1698 Just a Hook](http://blog.csdn.net/keshuai19940722/article/details/39374745)
- [hdu 3016 Man Down](http://blog.csdn.net/keshuai19940722/article/details/39995975)
- [uva 11992 - Fast Matrix Operations](http://blog.csdn.net/keshuai19940722/article/details/38818491)
- [uva 1232 - SKYLINE](http://blog.csdn.net/keshuai19940722/article/details/38820045)
- [uva 11402 - Ahoy, Pirates!](http://blog.csdn.net/keshuai19940722/article/details/38820191)
- [uva 10587 - Mayor's posters](http://blog.csdn.net/keshuai19940722/article/details/39586483)
- [Codeforces 444C DZY Loves Colors](http://blog.csdn.net/keshuai19940722/article/details/37561909)


##### 三、区间合并
**区间合并**是线段树的一个应用，一般解决类似一个区间有多少块连续1，连续1的最大长度等问题。区间合并比较明显的特征为向上更新时，需要考虑孩子节点的所表示的区间边界值。个人觉得区间合并的问题大致有这几种问法：
一个数组，初始都是0，现在有修改操作，可能将一段区间变成1或者0，现在有询问：
1. 多少段连续的1？
2. 区间上连续最长的长度（区间）？
3. 第k段连续1的区间？
4. 满足长度的最左区间？

###### 代码
注：L表示区间左端连续1的个数，R表示区间右端连续1的个数，C表示区间上连续有多少段连续的1，S表示区间上最长连续1的长度。
``` C++ pushup函数
void pushup(int u) {
	C[u] = C[lson(u)] + C[rson(u)] + (R[lson(u)] && L[rson(u)] ? -1 : 0);
	S[u] = max(max(S[lson(u)], S[rson(u)]), R[lson(u)] + L[rson(u)]);
	L[u] = L[lson(u)] + (L[lson(u)] == rc[lson(u)] - lc[lson(u)] + 1 ? L[rson(u)] : 0);
	R[u] = R[rson(u)] + (R[rson(u)] == rc[rson(u)] - lc[rson(u)] + 1 ? R[lson(u)] : 0);
}
```

``` C++ question 1
int query(int u, int l, int r) {
	if (l <= lc[u] && rc[u] <= r)
		return C[u];

	pushdown(u);
	int mid = (lc[u] + rc[u]) >> 1, ret;
	if (r <= mid)
		ret = query(lson(u), l, r);
	else if (l > mid)
		ret = query(rson(u), l, r);
	else
		ret = query(lson(u), l, r) + query(rson(u), l, r) - (R[lson(u)] && L[rson(u)] ? -1 : 0);
	pushup(u);
	return ret;
}
```

``` C++ question 2
int query (int u, int l, int r) {
	if (l <= lc[u] && rc[u] <= r)
		return S[u];
	pushdown(u);
	int mid = (lc[u] + rc[u]) >> 1, ret;
	if (r <= mid)
		ret = query(lson(u), l, r);
	else if (l > mid)
		ret = query(rson(u), l, r);
	else {
		int ll = query(lson(u), l, r);
		int rr = query(rson(u), l, r);

		int a = min(L[rson(u)], r - mid);
		int b = min(R[lson(u)], mid - l + 1);

		ret = max(max(ll, rr), a + b);
	}
	pushup(u);
	return ret;
}
```

``` C++ question 3
pii query(int u, int k) {
	if (k > C[u])
		return make_pair(0, 0);

	pushdown(u);
	pii ret;
	int mid = (lc[u] + rc[u]) >> 1;

	if (C[lson(u)] == k && R[lson(u)])
		ret = make_pair(mid - R[lson(u)] + 1, mid + L[rson(u)]);
	else if (C[lson(u)] <= k)
		ret = query(lson(u), k);
	else
		ret = query(rson(u), k - C[lson(u)] + (R[lson(u)] && L[rson(u)] ? 1 : 0));
	pushup(u);
	return ret;
}
```

``` C++ question 4
int query (int u, int k) {
    if (S[u] < k)
        return 0;

    pushdown(u);
    int ret;

    if (S[lson(u)] >= k)
        ret = query(lson(u), k);
    else if (R[lson(u)] + L[rson(u)] >= k) {
        int mid = (lc[u] + rc[u]) / 2;
        ret = mid - R[lson(u)] + 1;
    } else
        ret = query(rson(u), k);
    pushup(u);
    return ret;
}
```

###### 习题
- [hdu 3911 Black And White](http://blog.csdn.net/keshuai19940722/article/details/39637761)
- [poj 3667 Hotel](http://blog.csdn.net/keshuai19940722/article/details/39637921)
- [hdu 3308 LCIS](http://blog.csdn.net/keshuai19940722/article/details/39717897)
- [hdu 2871 Memory Control](http://blog.csdn.net/keshuai19940722/article/details/39717965)
- [hdu 1540 Tunnel Warfare](http://blog.csdn.net/keshuai19940722/article/details/39754245)
- [Codeforces 46D Parking Lot](http://blog.csdn.net/keshuai19940722/article/details/39754199)
- [uva 1400 - "Ray, Pass me the dishes!"](http://blog.csdn.net/keshuai19940722/article/details/38804707)


##### 四、扫描线
**扫描线**是线段树的另一种应用，进行区间修改，但是没有向下更新。一般问题就是求矩形面积的并，周长的并，或者是覆盖k次的面积。

###### 例题
以[hdu 1542 Atlantis](http://acm.hdu.edu.cn/showproblem.php?pid=1542)为例，给定N个矩形，问矩形面积的并。
将一个矩形拆分成两条线段，一条线段为增加，一条线段为减少，将线段按照y的顺序呢排序，从上向下扫描，维护每次修改后的覆盖面积。
- 因为横坐标可能会很大，所以很多时候要离散化处理。
- 线段树的维护中不能有pushdown操作，因为每一段区间的加都对应着减，如果将先前的加操作向下更新，那么后面的减操作将导致有负数的存在。

###### 图解
![Alt text](./1-3.png)

###### 代码
``` C++
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>

using namespace std;

const int maxn = 1005;

#define lson(x) ((x)<<1)
#define rson(x) (((x)<<1)|1)
int lc[maxn << 2], rc[maxn << 2], v[maxn << 2];
double s[maxn << 2];
vector<double> pos;

inline void pushup(int u) {
    if (v[u])
        s[u] = pos[rc[u] + 1] - pos[lc[u]];
    else if (rc[u] == lc[u])
        s[u] = 0;
    else
        s[u] = s[lson(u)] + s[rson(u)];
}

inline void add(int u, int set) {
    v[u] += set;
    pushup(u);
}

void build (int u, int l, int r) {
    lc[u] = l;
    rc[u] = r;
    v[u] = 0;
    s[u] = 0;

    if (l == r)
        return;

    int mid = (l + r) / 2;
    build(lson(u), l, mid);
    build(rson(u), mid + 1, r);
    pushup(u);
}

void modify (int u, int l, int r, int set) {
    if (l <= lc[u] && rc[u] <= r) {
        add(u, set);
        return;
    }

    int mid = (lc[u] + rc[u]) / 2;
    if (l <= mid)
        modify(lson(u), l, r, set);
    if (r > mid)
        modify(rson(u), l, r, set);
    pushup(u);
}

struct segment {
    double x;
    int l, r, set;
    segment (double x = 0, int l = 0, int r = 0, int set = 0) {
        this->x = x;
        this->l = l;
        this->r = r;
        this->set = set;
    }
};

int N;
vector<segment> vec;
double x1[maxn], x2[maxn], y1[maxn], y2[maxn];

inline bool cmp (const segment& a, const segment& b) {
    return a.x < b.x;
}

inline int find (double k) {
    return lower_bound(pos.begin(), pos.end(), k) - pos.begin();
}

int main () {
    int cas = 1;
    while (scanf("%d", &N) == 1 && N) {
        double ans = 0;
        vec.clear();
        pos.clear();

        for (int i = 0; i < N; i++) {
            scanf("%lf%lf%lf%lf", &x1[i], &y1[i], &x2[i], &y2[i]);
            pos.push_back(y1[i]);
            pos.push_back(y2[i]);
        }
        sort(pos.begin(), pos.end());
        build(1, 0, pos.size() * 2 - 1);

        for (int i = 0; i < N; i++) {
            vec.push_back(segment(x1[i], find(y1[i]), find(y2[i]) - 1, 1));
            vec.push_back(segment(x2[i], find(y1[i]), find(y2[i]) - 1, -1));
        }

        sort(vec.begin(), vec.end(), cmp);
        for (int i = 0; i < vec.size() - 1; i++) {
            modify(1, vec[i].l, vec[i].r, vec[i].set);
            ans += (s[1] * (vec[i+1].x - vec[i].x));
        }

        printf("Test case #%d\n", cas++);
        printf("Total explored area: %.2lf\n\n", ans);
    }
    return 0;
}
```
###### 习题
- [hdu 1542 Atlantis](http://blog.csdn.net/keshuai19940722/article/details/39754253)
- [hdu 1828 Picture](http://blog.csdn.net/keshuai19940722/article/details/39754283)
- [hdu 3255 Farming](http://blog.csdn.net/keshuai19940722/article/details/39996175)
- [hdu 3265 Posters](http://blog.csdn.net/keshuai19940722/article/details/39996387)
- [hdu 3642 Get The Treasury](http://blog.csdn.net/keshuai19940722/article/details/39997151)
- [poj 2482 Stars in Your Window](http://blog.csdn.net/keshuai19940722/article/details/40015205)(问题转换成扫描线)
- [uva 11983 - Weird Advertisement](http://blog.csdn.net/keshuai19940722/article/details/38872991)(覆盖k次的问题)
- [uva 1492 - Adding New Machine](http://blog.csdn.net/keshuai19940722/article/details/38873759)


##### 五、典型应用
- 第k大问题：每个节点维护一个值，表示有多少位置存在。（也可以用树状数组维护

``` C++ 第k大问题
int query (int u, int k) {
	if (lc[u] == rc[u])
		return lc[u];

	if (k > c[lson(u)])
		return query(rson(u), k - c[lson(u)]);
	else
		return query(lson(u), k);
}

void modify (int u, int x, int w) {
	if (lc[u] == x && rc[u] == x) {
		c[u] += w;
		return ;
	}

	int mid = (lc[u] + rc[u]) >> 1;
	if (x <= mid)
		modify(lson(u), x, w);
	else
		modify(rson(u), x, w);
	pushup(u);
}
```

- 等差数列：因为等差数列加上等差数列仍是一个等差数列。每个节点维护首项和公差即可。

[uva 12436 - Rip Van Winkle's Code](http://blog.csdn.net/keshuai19940722/article/details/40052933)
``` C++ 等差数列问题
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long ll;
const int maxn = 250100;

#define lson(x) ((x)<<1)
#define rson(x) (((x)<<1)|1)
int lc[maxn << 2], rc[maxn << 2], v[maxn << 2];
ll nd[maxn << 2], ad[maxn << 2], s[maxn << 2];

void pushup(int u);
void pushdown (int u);

inline int length(int u) {
    return rc[u] - lc[u] + 1;
}

inline void change (int u, ll a) {
    v[u] = 1;
    ad[u] = 0;
    nd[u] = a;
    s[u] = a * length(u);
}

inline void maintain (int u, ll a, ll d) {
    if (v[u] && lc[u] != rc[u]) {
        pushdown(u);
        pushup(u);
    }

    v[u] = 0;
    nd[u] += a;
    ad[u] += d;
    ll n = length(u);
    s[u] += a * n + (((n-1) * n) / 2) * d;
}

inline void pushup (int u) {
    s[u] = s[lson(u)] + s[rson(u)];
}

inline void pushdown (int u) {
    if (v[u]) {
        change(lson(u), nd[u]);
        change(rson(u), nd[u]);
        v[u] = nd[u] = 0;
    } else if (nd[u] || ad[u]) {
        maintain(lson(u), nd[u], ad[u]);
        maintain(rson(u), nd[u] + length(lson(u)) * ad[u], ad[u]);
        nd[u] = ad[u] = 0;
    }
}

void build (int u, int l, int r) {
    lc[u] = l;
    rc[u] = r;
    nd[u] = ad[u] = s[u] = 0;

    if (l == r)
        return;
    int mid = (l + r) / 2;
    build(lson(u), l, mid);
    build(rson(u), mid + 1, r);
    pushup(u);
}

void modify(int u, int l, int r, ll a, ll d) {
    if (l <= lc[u] && rc[u] <= r) {
        maintain(u, a + d * (lc[u] - l), d);
        return;
    }

    pushdown(u);
    int mid = (lc[u] + rc[u]) / 2;
    if (l <= mid)
        modify(lson(u), l, r, a, d);
    if (r > mid)
        modify(rson(u), l, r, a, d);
    pushup(u);
}

void set(int u, int l, int r, ll a) {
    if (l <= lc[u] && rc[u] <= r) {
        change(u, a);
        return;
    }

    pushdown(u);
    int mid = (lc[u] + rc[u]) / 2;
    if (l <= mid)
        set(lson(u), l, r, a);
    if (r > mid)
        set(rson(u), l, r, a);
    pushup(u);
}

ll query (int u, int l, int r) {
    if (l <= lc[u] && rc[u] <= r)
        return s[u];

    pushdown(u);
    ll ret = 0;
    int mid = (lc[u] + rc[u]) / 2;
    if (l <= mid)
        ret += query(lson(u), l, r);
    if (r > mid) 
        ret += query(rson(u), l, r);
    pushdown(u);
    return ret;
}

int N;

int main () {
    while (~scanf("%d", &N)) {
        char op[5];
        int l, r, x;
        build(1, 1, 250000);
        while (N--) {
            scanf("%s%d%d", op, &l, &r);
            if (op[0] == 'A')
                modify(1, l, r, 1, 1);
            else if (op[0] == 'B')
                modify(1, l, r, r - l + 1, -1);
            else if (op[0] == 'C') {
                scanf("%d", &x);
                set(1, l, r, x);
            } else
                printf("%lld\n", query(1, l, r));
        }
    }
    return 0;
}
```

- 去重问题：即查询一段区间是相同元素不重复考虑。

[hdu 3333 Turing Tree](http://blog.csdn.net/keshuai19940722/article/details/39996577)
``` C++ 去重问题
#include <cstdio>
#include <cstring>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

typedef long long ll;

const int maxn = 30000;

int N, Q;
ll A[maxn+5], ans[100005];
map<ll, int> G;

#define lson(x) ((x)<<1)
#define rson(x) (((x)<<1)|1)

int lc[maxn << 2], rc[maxn << 2];
ll s[maxn << 2];

inline void pushup (int u) {
    s[u] = s[lson(u)] + s[rson(u)];
}

void build (int u, int l, int r) {
    lc[u] = l;
    rc[u] = r;
    s[u] = 0;

    if (l == r)
        return;

    int mid = (lc[u] + rc[u]) / 2;
    build(lson(u), l, mid);
    build(rson(u), mid + 1, r);
    pushup(u);
}

void modify(int u, int x, ll d) {
    if (x == lc[u] && rc[u] == x) {
        s[u] += d;
        return;
    }

    int mid = (lc[u] + rc[u]) / 2;
    if (x <= mid)
        modify(lson(u), x, d);
    else
        modify(rson(u), x, d);
    pushup(u);
}

ll query(int u, int l, int r) {
    if (l <= lc[u] && rc[u] <= r)
        return s[u];

    ll ret = 0;
    int mid = (lc[u] + rc[u]) / 2;
    if (l <= mid)
        ret += query(lson(u), l, r);
    if (r > mid)
        ret += query(rson(u), l, r);
    pushup(u);
    return ret;
}

struct Seg {
    int l, r, id;
    Seg (int l = 0, int r = 0, int id = 0) {
        this->l = l;
        this->r = r;
        this->id = id;
    }
    friend bool operator < (const Seg& a, const Seg& b) {
        return a.r < b.r;
    }
};
vector<Seg> vec;

void init () {
    int l, r;
    G.clear();
    vec.clear();

    scanf("%d", &N);
    for (int i = 1; i <= N; i++)
        scanf("%lld", &A[i]);

    scanf("%d", &Q);
    for (int i = 1; i <= Q; i++) {
        scanf("%d%d", &l, &r);
        vec.push_back(Seg(l, r, i));
    }
    sort(vec.begin(), vec.end());
}

void solve () {
    build (1, 0, N);
    int k = 0;
    for (int i = 0; i < Q; i++) {
        for ( ; k <= vec[i].r; k++) {
            if (G[A[k]])
                modify(1, G[A[k]], -A[k]);
            G[A[k]] = k;
            modify(1, k, A[k]);
        }
        ans[vec[i].id] = query(1, vec[i].l, vec[i].r);
    }
    for (int i = 1; i <= Q; i++)
        printf("%lld\n", ans[i]);
}

int main () {
    int cas;
    scanf("%d", &cas);
    while (cas--) {
        init();
        solve();
    }
    return 0;
}
```

- 点的计数：计算一系列点的情况下，某个点左下角有多少个点（其他方向也可以）

这种问题一般将点按照x排序，相同的按照y排序，然后依次将点插入线段树中，对于询问也在过程中处理，查询[1，y]的个数即可。


##### 六、其他习题
- [uva 11525 - Permutation](http://blog.csdn.net/keshuai19940722/article/details/38820105)(第k大问题)
- [poj 2828 Buy Tickets](http://blog.csdn.net/keshuai19940722/article/details/39374979)(第k大问题)
- [ural 1707. Hypnotoad's Secret](http://blog.csdn.net/keshuai19940722/article/details/40053193)(点个数的计算)
- [Codeforces 85D - Sum of Medians](http://blog.csdn.net/keshuai19940722/article/details/39996967)
- [Codeforces 380C Sereja and Brackets](http://blog.csdn.net/keshuai19940722/article/details/19014821)
- [zoj 3813 Alternating Sum](http://blog.csdn.net/keshuai19940722/article/details/39178891)
- [zoj 3511 Cake Robbery](http://blog.csdn.net/keshuai19940722/article/details/40040129)
- [poj 2991 Crane](http://blog.csdn.net/keshuai19940722/article/details/39586143)(结合几何的一道题目)
- [poj 1436 Horizontally Visible Segments](http://blog.csdn.net/keshuai19940722/article/details/39585909)
- [uva 1455 - Kingdom](http://blog.csdn.net/keshuai19940722/article/details/38874003)(结合并查集)
- [hdu 3874 Necklace](http://blog.csdn.net/keshuai19940722/article/details/39997233)
- [hdu 3954 Level up](http://blog.csdn.net/keshuai19940722/article/details/40015031)
- [hdu 4027 Can you answer these queries?](http://blog.csdn.net/keshuai19940722/article/details/40015059)
- [hdu 5023 A Corrupt Mayor's Performance Art](http://blog.csdn.net/keshuai19940722/article/details/39476017)
- [hdu 3397 Sequence operation](http://blog.csdn.net/keshuai19940722/article/details/39717919)(模拟区间操作，不错的一题)
- [hdu 2795 Billboard](http://blog.csdn.net/keshuai19940722/article/details/39350369)

-------------------















